

import unittest
from io import StringIO
import sys
import random
from unittest.mock import patch, MagicMock
from game_state_manager import Card, Score, evaluate_hand, Game

## 
# This file is generated by Claude Sonnet 3.7.
# It proivdes unit test for games_state_manager.py for debugging purposes
# Using this unit test, the autor, Justin Kim, was able to detect some errors in
# Game.decide_winner(), check_flush(), count_frequencies()
# #


class TestCard(unittest.TestCase):
    def test_card_creation(self):
        """Test that cards are created correctly"""
        card = Card("H", 1)  # Ace of Hearts
        self.assertEqual(card.suit, "H")
        self.assertEqual(card.rank, 1)
        self.assertEqual(str(card), "AH")
        
        card = Card("S", 10)  # 10 of Spades
        self.assertEqual(card.suit, "S")
        self.assertEqual(card.rank, 10)
        self.assertEqual(str(card), "10S")

class TestScore(unittest.TestCase):
    def test_score_ordering(self):
        """Test that hand scores are ordered correctly"""
        # Create scores for different hands
        straight_flush = Score("straight flush", higher=10)
        four_kind = Score("four of a kind", higher=7, first=9)
        full_house = Score("full house", higher=8, lower=3)
        flush = Score("flush", first=12, second=10, third=8, fourth=7, fifth=3)
        straight = Score("straight", higher=8)
        three_kind = Score("triple", higher=9, first=12, second=8)
        two_pair = Score("two pair", higher=11, lower=9, first=7)
        one_pair = Score("one pair", higher=10, first=13, second=8, third=7)
        high_card = Score("no pair", first=13, second=10, third=8, fourth=7, fifth=5)
        
        # Test that hands are ordered correctly
        self.assertGreater(straight_flush.get_score(), four_kind.get_score())
        self.assertGreater(four_kind.get_score(), full_house.get_score())
        self.assertGreater(full_house.get_score(), flush.get_score())
        self.assertGreater(flush.get_score(), straight.get_score())
        self.assertGreater(straight.get_score(), three_kind.get_score())
        self.assertGreater(three_kind.get_score(), two_pair.get_score())
        self.assertGreater(two_pair.get_score(), one_pair.get_score())
        self.assertGreater(one_pair.get_score(), high_card.get_score())
    
    def test_tiebreakers(self):
        """Test that tiebreakers work correctly"""
        # Test pair tiebreaker
        high_pair = Score("one pair", higher=10, first=13, second=8, third=7)
        low_pair = Score("one pair", higher=9, first=13, second=8, third=7)
        self.assertGreater(high_pair.get_score(), low_pair.get_score())
        
        # Test kicker tiebreaker
        high_kicker = Score("one pair", higher=10, first=13, second=8, third=7)
        low_kicker = Score("one pair", higher=10, first=12, second=8, third=7)
        self.assertGreater(high_kicker.get_score(), low_kicker.get_score())

class TestHandEvaluation(unittest.TestCase):
    def test_straight_flush(self):
        """Test straight flush detection"""
        hand = [
            Card("H", 10), Card("H", 11), Card("H", 12), 
            Card("H", 13), Card("H", 1),  # Royal flush
            Card("S", 3),  Card("D", 5)   # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "straight flush")
        self.assertEqual(result.higher, 1)  # Ace-high straight
        
    def test_four_of_a_kind(self):
        """Test four of a kind detection"""
        hand = [
            Card("H", 8), Card("S", 8), Card("D", 8), 
            Card("C", 8),  # Four 8s
            Card("H", 13), Card("S", 4), Card("D", 6)  # Kickers
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "four of a kind")
        self.assertEqual(result.higher, 8)  # 8s
        self.assertEqual(result.first, 13)  # King kicker
        
    def test_full_house(self):
        """Test full house detection"""
        hand = [
            Card("H", 7), Card("S", 7), Card("D", 7),  # Three 7s
            Card("H", 2), Card("S", 2),  # Two 2s
            Card("D", 10), Card("C", 4)  # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "full house")
        self.assertEqual(result.higher, 7)  # 7s
        self.assertEqual(result.lower, 2)   # 2s
    
    def test_flush(self):
        """Test flush detection"""
        hand = [
            Card("S", 2), Card("S", 5), Card("S", 7),
            Card("S", 10), Card("S", 1),  # Spade flush with Ace high
            Card("H", 13), Card("D", 12)  # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "flush")
        self.assertEqual(result.first, 1)  # Ace
        self.assertEqual(result.second, 10)  # 10
    
    def test_straight(self):
        """Test straight detection"""
        hand = [
            Card("H", 5), Card("S", 6), Card("D", 7),
            Card("C", 8), Card("H", 9),  # Straight 5-9
            Card("S", 2), Card("D", 2)  # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "straight")
        self.assertEqual(result.higher, 9)  # 9-high straight
    
    def test_three_of_a_kind(self):
        """Test three of a kind detection"""
        hand = [
            Card("H", 9), Card("S", 9), Card("D", 9),  # Three 9s
            Card("C", 5), Card("H", 1),  # Kickers (Ace and 5)
            Card("S", 3), Card("D", 7)  # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "triple")
        self.assertEqual(result.higher, 9)  # 9s
        self.assertEqual(result.first, 1)  # Ace kicker
        
    def test_two_pair(self):
        """Test two pair detection"""
        hand = [
            Card("H", 10), Card("S", 10),  # Pair of 10s
            Card("D", 4), Card("C", 4),  # Pair of 4s
            Card("H", 1),  # Kicker (Ace)
            Card("S", 7), Card("D", 3)  # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "two pair")
        self.assertEqual(result.higher, 10)  # 10s
        self.assertEqual(result.lower, 4)   # 4s
        self.assertEqual(result.first, 1)  # Ace kicker
    
    def test_one_pair(self):
        """Test one pair detection"""
        hand = [
            Card("H", 6), Card("S", 6),  # Pair of 6s
            Card("D", 13), Card("C", 10), Card("H", 8),  # Kickers (K, 10, 8)
            Card("S", 3), Card("D", 2)  # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "one pair")
        self.assertEqual(result.higher, 6)  # 6s
        self.assertEqual(result.first, 13)  # King kicker
        self.assertEqual(result.second, 10)  # 10 kicker
        self.assertEqual(result.third, 8)   # 8 kicker
    
    def test_high_card(self):
        """Test high card detection"""
        hand = [
            Card("H", 1), Card("S", 10), Card("D", 8),
            Card("C", 6), Card("H", 4),  # High card hand
            Card("S", 3), Card("D", 2)  # Irrelevant cards
        ]
        result = evaluate_hand(hand)
        self.assertEqual(result.category, "no pair")
        self.assertEqual(result.first, 1)  # Ace high
        self.assertEqual(result.second, 10)  # 10 second
        self.assertEqual(result.third, 8)   # 8 third
        self.assertEqual(result.fourth, 6)  # 6 fourth
        self.assertEqual(result.fifth, 4)   # 4 fifth

class TestGameOutcomes(unittest.TestCase):
    def simulate_game_with_betting(self, game, mock_deal_func):
        """Helper method to run a simulated game with proper betting"""
        # Suppress prints for cleaner test output
        with patch('builtins.print'), patch('builtins.input', return_value=''):
            # Override the deal_hole_cards method
            game.deal_hole_cards = mock_deal_func
            
            # Modify the game to work in test mode
            # We'll simulate players betting 10 each round
            round_count = [0]  # Use a list to allow modification in the nested function
            
            def mock_wait_for_bet(player):
                round_count[0] += 1
                # In preflop, player 0 should call 10, player 1 already put in blind
                if round_count[0] <= 2:  # Preflop round
                    return "call"  # Both players call
                elif round_count[0] <= 4:  # Flop round
                    if player == 0:
                        return "raise:10"  # Player 0 raises 10
                    else:
                        return "call"  # Player 1 calls
                elif round_count[0] <= 6:  # Turn round
                    if player == 0:
                        return "raise:10"  # Player 0 raises 10
                    else:
                        return "call"  # Player 1 calls
                else:  # River round
                    if player == 0:
                        return "raise:10"  # Player 0 raises 10
                    else:
                        return "call"  # Player 1 calls
            
            game.wait_for_bet = mock_wait_for_bet
            
            # Run the game
            game.start_game()
    
    def test_simulated_game_player_with_flush_wins(self):
        """Test a specific scenario where player with a flush wins"""
        # Create a game with predetermined settings
        game = Game(2, 5, 1000)
        
        # Define card dealing function
        def mock_deal():
            # Player 0 gets a heart flush
            game.hands[0] = [Card("H", 1), Card("H", 3)]  # Ace, 3 of hearts
            # Player 1 gets a pair of kings
            game.hands[1] = [Card("S", 13), Card("D", 13)]  # King of spades, king of diamonds
            # Community cards to complete the flush for player 0
            game.community_deck = [
                Card("H", 5), Card("H", 7), Card("H", 10),  # Flop - hearts
                Card("S", 2),  # Turn - spade
                Card("D", 4)   # River - diamond
            ]
        
        # Run the game
        self.simulate_game_with_betting(game, mock_deal)
        
        # Verify the outcome: player 0 should win with a flush
        self.assertGreater(game.pots[0], 1000, "Player 0 should win with a flush")
        self.assertLess(game.pots[1], 1000, "Player 1 should lose with pair of kings")
    
    def test_full_house_beats_flush(self):
        """Test that a full house beats a flush"""
        # Create a game with predetermined settings
        game = Game(2, 5, 1000)
        
        # Define card dealing function
        def mock_deal():
            # Player 0 gets two kings for a full house
            game.hands[0] = [Card("H", 13), Card("D", 13)]  # Kings
            # Player 1 gets two hearts for a flush
            game.hands[1] = [Card("H", 2), Card("H", 3)]    # Hearts
            # Community cards: add three queens for player 0's full house
            # and three more hearts for player 1's flush
            game.community_deck = [
                Card("S", 12), Card("D", 12), Card("C", 12),  # Three queens
                Card("H", 7),  # Another heart
                Card("H", 9)   # Another heart
            ]
        
        # Run the game
        self.simulate_game_with_betting(game, mock_deal)
        
        # Verify the outcome: player 0 should win with a full house
        self.assertGreater(game.pots[0], 1000, "Player 0 should win with full house")
        self.assertLess(game.pots[1], 1000, "Player 1 should lose with flush")
    
    def test_higher_flush_wins(self):
        """Test that a higher flush beats a lower flush"""
        # Create a game with predetermined settings
        game = Game(2, 5, 1000)
        
        # Define card dealing function
        def mock_deal():
            # Player 0 gets ace-high spade flush
            game.hands[0] = [Card("S", 1), Card("S", 10)]  # Ace, 10 of spades
            # Player 1 gets king-high spade flush
            game.hands[1] = [Card("S", 13), Card("S", 9)]  # King, 9 of spades
            # Community cards: more spades
            game.community_deck = [
                Card("S", 2), Card("S", 5), Card("S", 7),  # Spades for both flushes
                Card("H", 3),  # Heart
                Card("D", 4)   # Diamond
            ]
        
        # Run the game
        self.simulate_game_with_betting(game, mock_deal)
        
        # Verify the outcome: player 0 should win with ace-high flush
        self.assertGreater(game.pots[0], 1000, "Player 0 should win with ace-high flush")
        self.assertLess(game.pots[1], 1000, "Player 1 should lose with king-high flush")
    
    def test_straight_vs_two_pair(self):
        """Test that a straight beats two pair"""
        # Create a game with predetermined settings
        game = Game(2, 5, 1000)
        
        # Define card dealing function
        def mock_deal():
            # Player 0 gets 6-7 for a straight
            game.hands[0] = [Card("H", 6), Card("S", 7)]
            # Player 1 gets two kings
            game.hands[1] = [Card("H", 13), Card("S", 13)]
            # Community cards: complete the straight for player 0 
            # and give another pair to player 1
            game.community_deck = [
                Card("D", 8), Card("C", 9), Card("S", 10),  # For straight
                Card("H", 2),  # For two pair
                Card("S", 2)   # For two pair
            ]
        
        # Run the game
        self.simulate_game_with_betting(game, mock_deal)
        
        # Verify the outcome: player 0 should win with a straight
        self.assertGreater(game.pots[0], 1000, "Player 0 should win with straight")
        self.assertLess(game.pots[1], 1000, "Player 1 should lose with two pair")
    
    def test_split_pot_with_same_hand(self):
        """Test that identical hands result in a split pot"""
        # Create a game with predetermined settings
        game = Game(2, 5, 1000)
        
        # Define card dealing function
        def mock_deal():
            # Both players get an ace
            game.hands[0] = [Card("H", 1), Card("H", 2)]  # Ace of hearts, 2 of hearts
            game.hands[1] = [Card("S", 1), Card("S", 3)]  # Ace of spades, 3 of spades
            # Community cards: Both players make identical hands
            game.community_deck = [
                Card("D", 10), Card("C", 9), Card("S", 8),  # Shared high cards
                Card("H", 7),  
                Card("S", 6)  
            ]
        
        # Run the game
        self.simulate_game_with_betting(game, mock_deal)
        
        # Calculate how much each player should have put into the pot during betting
        # Small blind (5) + Big blind (10) + 3 rounds of raising (30 each)
        total_bet_per_player = 45
        
        # Verify the outcome: each player should get their money back in a tie
        # They should have 1000 - 45 (betting) + 45 (winnings) = 1000
        self.assertEqual(game.pots[0], 1000, "Player 0 should get back their money in a split pot")
        self.assertEqual(game.pots[1], 1000, "Player 1 should get back their money in a split pot")

def run_tests():
    # Create a test suite
    test_suite = unittest.TestSuite()
    
    # Add test cases
    test_suite.addTest(unittest.makeSuite(TestCard))
    test_suite.addTest(unittest.makeSuite(TestScore))
    test_suite.addTest(unittest.makeSuite(TestHandEvaluation))
    test_suite.addTest(unittest.makeSuite(TestGameOutcomes))
    
    # Run the tests
    runner = unittest.TextTestRunner(verbosity=2)
    result = runner.run(test_suite)
    
    return result.wasSuccessful()

if __name__ == "__main__":
    success = run_tests()
    sys.exit(0 if success else 1)